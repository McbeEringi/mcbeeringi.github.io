import { ContextTracker, ExternalTokenizer, LRParser } from "./@lezer-lr.js";
import { styleTags, tags } from "./@lezer-highlight.js";

// This file was generated by lezer-generator. You probably shouldn't edit it.
const blockEnd = 59,
  eof = 60,
  DirectiveEnd = 1,
  DocEnd = 2,
  sequenceStartMark = 3,
  sequenceContinueMark = 4,
  explicitMapStartMark = 5,
  explicitMapContinueMark = 6,
  flowMapMark = 7,
  mapStartMark = 61,
  mapContinueMark = 62,
  Literal = 8,
  QuotedLiteral = 9,
  Anchor = 10,
  Alias = 11,
  Tag = 12,
  BlockLiteralContent = 13,
  BracketL = 19,
  FlowSequence = 20,
  Colon = 29,
  BraceL = 32,
  FlowMapping = 33;

const type_Top = 0, type_Seq = 1, type_Map = 2, type_Flow = 3;

class Context {
  constructor(parent, depth, type) {
    this.parent = parent;
    this.depth = depth;
    this.type = type;
    this.hash = (parent ? parent.hash + parent.hash << 8 : 0) + depth + (depth << 4) + type;
  }

  static top = new Context(null, -1, type_Top)
}

function findColumn(input, pos) {
  for (let col = 0, p = pos - input.pos - 1;; p--, col++) {
    let ch = input.peek(p);
    if (isBreakSpace(ch) || ch == -1) return col
  }
}

function isNonBreakSpace(ch) {
  return ch == 32 || ch == 9
}

function isBreakSpace(ch) {
  return ch == 10 || ch == 13
}

function isSpace(ch) {
  return isNonBreakSpace(ch) || isBreakSpace(ch)
}

function isSep(ch) {
  return ch < 0 || isSpace(ch)
}

const indentation = new ContextTracker({
  start: Context.top,
  reduce(context, term) {
    return context.type == type_Flow && (term == FlowSequence || term == FlowMapping) ? context.parent : context
  },
  shift(context, term, stack, input) {
    if (term == sequenceStartMark)
      return new Context(context, findColumn(input, input.pos), type_Seq)
    if (term == mapStartMark || term == explicitMapStartMark)
      return new Context(context, findColumn(input, input.pos), type_Map)
    if (term == blockEnd)
      return context.parent
    if (term == BracketL || term == BraceL)
      return new Context(context, 0, type_Flow)
    return context
  },
  hash(context) { return context.hash }
});

function three(input, ch, off = 0) {
  return input.peek(off) == ch && input.peek(off + 1) == ch && input.peek(off + 2) == ch && isSep(input.peek(off + 3))
}

const newlines = new ExternalTokenizer((input, stack) => {
  if (input.next == -1 && stack.canShift(eof))
    return input.acceptToken(eof)
  let prev = input.peek(-1);
  if ((isBreakSpace(prev) || prev < 0) && stack.context.type != type_Flow) {
    if (three(input, 45 /* '-' */)) {
      if (stack.canShift(blockEnd)) input.acceptToken(blockEnd);
      else return input.acceptToken(DirectiveEnd, 3)
    }
    if (three(input, 46 /* '.' */)) {
      if (stack.canShift(blockEnd)) input.acceptToken(blockEnd);
      else return input.acceptToken(DocEnd, 3)
    }
    let depth = 0;
    while (input.next == 32 /* ' ' */) { depth++; input.advance(); }
    if ((depth < stack.context.depth ||
         depth == stack.context.depth && stack.context.type == type_Seq &&
         (input.next != 45 /* '-' */ || !isSep(input.peek(1)))) &&
        // Not blank
        input.next != -1 && input.next != 10 && input.next != 13 && input.next != 35 /* '#' */)
      input.acceptToken(blockEnd, -depth);
  }
}, {contextual: true});

const blockMark = new ExternalTokenizer((input, stack) => {
  if (stack.context.type == type_Flow) {
    if (input.next == 63 /* '?' */) {
      input.advance();
      if (isSep(input.next)) input.acceptToken(flowMapMark);
    }
    return
  }
  if (input.next == 45 /* '-' */) {
    input.advance();
    if (isSep(input.next))
      input.acceptToken(stack.context.type == type_Seq && stack.context.depth == findColumn(input, input.pos - 1)
                        ? sequenceContinueMark : sequenceStartMark);
  } else if (input.next == 63 /* '?' */) {
    input.advance();
    if (isSep(input.next))
      input.acceptToken(stack.context.type == type_Map && stack.context.depth == findColumn(input, input.pos - 1)
                        ? explicitMapContinueMark : explicitMapStartMark);
  } else {
    let start = input.pos;
    // Scan over a potential key to see if it is followed by a colon.
    for (;;) {
      if (isNonBreakSpace(input.next)) {
        if (input.pos == start) return
        input.advance();
      } else if (input.next == 33 /* '!' */) {
        readTag(input);
      } else if (input.next == 38 /* '&' */) {
        readAnchor(input);
      } else if (input.next == 42 /* '*' */) {
        readAnchor(input);
        break
      } else if (input.next == 39 /* "'" */ || input.next == 34 /* '"' */) {
        if (readQuoted(input, true)) break
        return
      } else if (input.next == 91 /* '[' */ || input.next == 123 /* '{' */) {
        if (!scanBrackets(input)) return
        break
      } else {
        readPlain(input, true, false, 0);
        break
      }
    }
    while (isNonBreakSpace(input.next)) input.advance();
    if (input.next == 58 /* ':' */) {
      if (input.pos == start && stack.canShift(Colon)) return
      let after = input.peek(1);
      if (isSep(after))
        input.acceptTokenTo(stack.context.type == type_Map && stack.context.depth == findColumn(input, start)
                            ? mapContinueMark : mapStartMark, start);
    }
  }
}, {contextual: true});

function uriChar(ch) {
  return ch > 32 && ch < 127 && ch != 34 && ch != 37 && ch != 44 && ch != 60 &&
    ch != 62 && ch != 92 && ch != 94 && ch != 96 && ch != 123 && ch != 124 && ch != 125
}

function hexChar(ch) {
  return ch >= 48 && ch <= 57 || ch >= 97 && ch <= 102 || ch >= 65 && ch <= 70
}

function readUriChar(input, quoted) {
  if (input.next == 37 /* '%' */) {
    input.advance();
    if (hexChar(input.next)) input.advance();
    if (hexChar(input.next)) input.advance();
    return true
  } else if (uriChar(input.next) || quoted && input.next == 44 /* ',' */) {
    input.advance();
    return true
  }
  return false
}

function readTag(input) {
  input.advance(); // !
  if (input.next == 60 /* '<' */) {
    input.advance();
    for (;;) {
      if (!readUriChar(input, true)) {
        if (input.next == 62 /* '>' */) input.advance();
        break
      }
    }
  } else {
    while (readUriChar(input, false)) {}
  }
}

function readAnchor(input) {
  input.advance();
  while (!isSep(input.next) && charTag(input.tag) != "f") input.advance();
}
  
function readQuoted(input, scan) {
  let quote = input.next, lineBreak = false, start = input.pos;
  input.advance();
  for (;;) {
    let ch = input.next;
    if (ch < 0) break
    input.advance();
    if (ch == quote) {
      if (ch == 39 /* "'" */) {
        if (input.next == 39) input.advance();
        else break
      } else {
        break
      }
    } else if (ch == 92 /* "\\" */ && quote == 34 /* '"' */) {
      if (input.next >= 0) input.advance();
    } else if (isBreakSpace(ch)) {
      if (scan) return false
      lineBreak = true;
    } else if (scan && input.pos >= start + 1024) {
      return false
    }
  }
  return !lineBreak
}

function scanBrackets(input) {
  for (let stack = [], end = input.pos + 1024;;) {
    if (input.next == 91 /* '[' */ || input.next == 123 /* '{' */) {
      stack.push(input.next);
      input.advance();
    } else if (input.next == 39 /* "'" */ || input.next == 34 /* '"' */) {
      if (!readQuoted(input, true)) return false
    } else if (input.next == 93 /* ']' */ || input.next == 125 /* '}' */) {
      if (stack[stack.length - 1] != input.next - 2) return false
      stack.pop();
      input.advance();
      if (!stack.length) return true
    } else if (input.next < 0 || input.pos > end || isBreakSpace(input.next)) {
      return false
    } else {
      input.advance();
    }
  }
}

// "Safe char" info for char codes 33 to 125. s: safe, i: indicator, f: flow indicator
const charTable = "iiisiiissisfissssssssssssisssiiissssssssssssssssssssssssssfsfssissssssssssssssssssssssssssfif";

function charTag(ch) {
  if (ch < 33) return "u"
  if (ch > 125) return "s"
  return charTable[ch - 33]
}

function isSafe(ch, inFlow) {
  let tag = charTag(ch);
  return tag != "u" && !(inFlow && tag == "f")
}

function readPlain(input, scan, inFlow, indent) {
  if (charTag(input.next) == "s" ||
      (input.next == 63 /* '?' */ || input.next == 58 /* ':' */ || input.next == 45 /* '-' */) &&
      isSafe(input.peek(1), inFlow)) {
    input.advance();
  } else {
    return false
  }
  let start = input.pos;
  for (;;) {
    let next = input.next, off = 0, lineIndent = indent + 1;
    while (isSpace(next)) {
      if (isBreakSpace(next)) {
        if (scan) return false
        lineIndent = 0;
      } else {
        lineIndent++;
      }
      next = input.peek(++off);
    }
    let safe = next >= 0 &&
        (next == 58 /* ':' */ ? isSafe(input.peek(off + 1), inFlow) :
         next == 35 /* '#' */ ? input.peek(off - 1) != 32 /* ' ' */ :
         isSafe(next, inFlow));
    if (!safe || !inFlow && lineIndent <= indent ||
        lineIndent == 0 && !inFlow && (three(input, 45, off) || three(input, 46, off)))
      break
    if (scan && charTag(next) == "f") return false
    for (let i = off; i >= 0; i--) input.advance();
    if (scan && input.pos > start + 1024) return false
  }
  return true
}

const literals = new ExternalTokenizer((input, stack) => {
  if (input.next == 33 /* '!' */) {
    readTag(input);
    input.acceptToken(Tag);
  } else if (input.next == 38 /* '&' */ || input.next == 42 /* '*' */) {
    let token = input.next == 38 ? Anchor : Alias;
    readAnchor(input);
    input.acceptToken(token);
  } else if (input.next == 39 /* "'" */ || input.next == 34 /* '"' */) {
    readQuoted(input, false);
    input.acceptToken(QuotedLiteral);
  } else if (readPlain(input, false, stack.context.type == type_Flow, stack.context.depth)) {
    input.acceptToken(Literal);
  }
});

const blockLiteral = new ExternalTokenizer((input, stack) => {
  let indent = -1, upto = input.pos;
  scan: for (;;) {
    let depth = 0, next = input.next;
    while (next == 32 /* ' ' */) next = input.peek(++depth);
    if (!depth && (three(input, 45, depth) || three(input, 46, depth))) break
    if (!isBreakSpace(next)) {
      if (indent < 0) indent = Math.max(stack.context.depth + 1, depth);
      if (depth < indent) break
    }
    for (;;) {
      if (input.next < 0) break scan
      let isBreak = isBreakSpace(input.next);
      input.advance();
      if (isBreak) continue scan
      upto = input.pos;
    }
  }
  input.acceptTokenTo(BlockLiteralContent, upto);
});

const yamlHighlighting = styleTags({
  DirectiveName: tags.keyword,
  DirectiveContent: tags.attributeValue,
  "DirectiveEnd DocEnd": tags.meta,
  QuotedLiteral: tags.string,
  BlockLiteralHeader: tags.special(tags.string),
  BlockLiteralContent: tags.content,
  Literal: tags.content,
  "Key/Literal Key/QuotedLiteral": tags.definition(tags.propertyName),
  "Anchor Alias": tags.labelName,
  Tag: tags.typeName,
  Comment: tags.lineComment,
  ": , -": tags.separator,
  "?": tags.punctuation,
  "[ ]": tags.squareBracket,
  "{ }": tags.brace
});

// This file was generated by lezer-generator. You probably shouldn't edit it.
const parser = LRParser.deserialize({
  version: 14,
  states: "4WQ!ZQgOOO#PQfO'#CpO#uQfO'#C}OOQR'#Dr'#DrO$qQgO'#DQO%OQcO'#DPO%rQdO'#DTO%yQgO'#DTO&^QcO'#DSO&lOaO'#DWOOQR'#Dq'#DqO'fQgO'#DYO(]QgO'#D[OOQR'#Dp'#DpO)SOqO'#D^OOQP'#Df'#DfO)eQaO'#CmO)sQgO'#CmOOQP'#Cm'#CmQ*TQaOOQ*`QgOOQ]QgOOO*jQdO'#CrO+XQdO'#CtOOQO'#Ds'#DsO+vQ`O'#CxO,RQdO'#CwO,]Q`O'#CwO,bQdO'#CwOOQO'#Cv'#CvOOQO'#Cq'#CqO,oQ`O,59[O,wQfO,59[OOQR,59[,59[OOQO'#Cx'#CxO-OQ`O'#DOO-ZQdO'#DOO-eQdO'#DOO-rQ`O,59iO-zQfO,59iOOQR,59i,59iOOQR,59l,59lO.RQgO'#DROOQR'#Dd'#DdO.`QcO,59kOOQR,59k,59kO.kQgO,59oO.{Q`O,59oOOQR'#DU'#DUO#|QfO,59oO/QQcO,59oO/cQdO'#DVO/jQgO'#DVOOQR'#De'#DeO/}QcO,59nOOQR,59n,59nOOQR,59r,59rO0]OWO,59rO0bOaO,59rO0jOaO,59rO0uQgO'#DZOOQR,59t,59tO1iQgO'#D]OOQR,59v,59vOOQP,59x,59xO2]OaO,59xO2eOaO,59xO2sOqO,59xOOQP-E7d-E7dO3RQgO,59XOOQP,59X,59XO3cQaO'#DaO3qQgO'#DaO4RQgO'#DgOOQP'#Dg'#DgQ*TQaOOO4cQdO'#CsOOQO,59^,59^O4}QdO'#CuOOQO,59`,59`OOQO,59c,59cO5iQdO,59cO5sQ`O,59cOOQU,59|,59|OOQR1G.v1G.vO5xQ`O1G.vOOQU-E7`-E7`O6QQdO,59jOOQO,59j,59jO6[Q`O,59jOOQU,59},59}OOQR1G/T1G/TO6aQ`O1G/TOOQU-E7a-E7aOOQR,59m,59mOOQR-E7b-E7bOOQR1G/V1G/VOOQR1G/Z1G/ZO6iQgO1G/ZO#|QfO1G/ZO6yQgO,59qO7ZQ`O,59qO#|QfO,59qO7`QcO,59qOOQR-E7c-E7cOOQR1G/Y1G/YOOQR1G/^1G/^O7qOWO1G/^O7vOaO1G/^OOQR,59u,59uOOQR,59w,59wOOQP1G/d1G/dO8OOaO1G/dO8WOaO1G/dO8cOaO1G/dOOQP1G.s1G.sO8qQgO,59{OOQP,59{,59{OOQP,5:R,5:ROOQP-E7e-E7eOOQO,59_,59_OOQO,59a,59aOOQO1G.}1G.}O9RQdO1G.}OOQR7+$b7+$bP,rQ`O'#DbOOQO1G/U1G/UO9]QdO1G/UOOQR7+$o7+$oP9gQ`O'#DcOOQR7+$u7+$uOOQR1G/]1G/]O9lQgO1G/]O#|QfO1G/]OOQR7+$x7+$xO9|OWO7+$xOOQP7+%O7+%OO:ROaO7+%OO:ZOaO7+%OOOQP1G/g1G/gOOQO7+$i7+$iOOQO7+$p7+$pOOQR7+$w7+$wOOQR<<Hd<<HdOOQP<<Hj<<HjO:fOaO<<HjOOQPAN>UAN>U",
  stateData: ":n~O!bOS!cOS^OS~OPaOQdORSOTVOWROXROY[OZ]O[ZOcPOpQO{XO!R^O!_UO~O`eO~P]OVlOWROXROYgOZhO[fOcPOmjOpQO~ObqO~P!bOVuOWROXROYgOZhO[fOcPOmtOpQO~OoxO~P#WORSOTVOWROXROY[OZ]O[ZOcPOpQO{XO!_UO~OStX!]tX!^tX~P#|OSzO!]}O!^}O~OWROXROYgOZhO[fOcPOpQO~Om!OO~P%ZOm!ROUwX!]wX!^wX!`wX~P#|OU!UO!]!XO!^!XO!`!TO~O^![O!^!YO!b!]O!c!ZO~ORSOTVOWROXROcPOpQO{XO!_UO~OY!^OP|XQ|X!R|X![|XS|X!]|X!^|XU|Xm|X!`|X~P&zO[!`OP!OXQ!OX!R!OX![!OXS!OX!]!OX!^!OXU!OXm!OX!`!OX~P&zO^!cO!S!dO!^!bO!b!eO!c!bO~OP!gO!R^OQaX![aX~OPaXQaX!RaX![aX~P#|OP!jOQ!kO!R^O~OPaO!R^O~P#|OWROXROY!nOcPOpQObfXmfXnfXofX~OWROXRO[!pOcPOpQObhXmhXnhXohX~ObeXmlXneX~ObkXnkX~P%ZOm!sO~Om!sObkXnkX~P%ZOb!vOn!uO~Ob!vO~P!bOm!yOnrXorX~OnrXorX~P%ZOm!yOnrXorX~P%ZOn!|Oo!}O~Oo!}O~P#WOSuX!]uX!^uX~P#|OSzO!]#SO!^#SO~OUwa!]wa!^wa!`wa~P#|Om#UO~Om#VOUwa!]wa!^wa!`wa~Om#WO~P%ZOm#YOUyX!]yX!^yX!`yX~P#|OU!UO!]#]O!^#]O!`!TO~O]#^O~O!^#^O!c#_O~O^#`O!^#^O!c#_O~OP}XQ}X!R}X![}XS}X!]}X!^}XU}Xm}X!`}X~P&zOP!PXQ!PX!R!PX![!PXS!PX!]!PX!^!PXU!PXm!PX!`!PX~P&zO!^#cO!c#cO~O^#dO!^#cO!b#eO!c#cO~O^#dO!S#fO!^#cO!c#cO~OPaaQaa!Raa![aa~P#|OP#hO!R^OQ!TX![!TX~OP!TXQ!TX!R!TX![!TX~P#|OPaO!R^OQ!ZX![!ZX~P#|OWROXROcPOpQObgXmgXngXogX~OWROXROcPOpQObiXmiXniXoiX~Obkanka~P%ZOm#oO~Ob#pOn!uO~Onraora~P%ZOm#sO~On!|Oo#tO~OUwi!]wi!^wi!`wi~P#|OUya!]ya!^ya!`ya~P#|Om#xO~Om#yOUya!]ya!^ya!`ya~O]#zO~O!^#zO!c#{O~O!^#|O!c#|O~O^#}O!^#|O!c#|O~O^#}O!^#|O!b$OO!c#|O~OP!TaQ!Ta!R!Ta![!Ta~P#|Obkinki~P%ZOnriori~P%ZOn!|O~OUyi!]yi!^yi!`yi~P#|O]$TO~O!^$UO!c$UO~O^$VO!^$UO!c$UO~O!^$WO!c$WO~O",
  goto: ",d!hPPPPPPPPPPPPPPPPP!iPP!q#o#u$V#u$Y$]$a$ePPPP!q$|%S%n&Y%S&^&x'O%SP'S'j'S'm'pPP'z(O(U([(b(h(vPPPPPPPP(|)z*n+vUcOdeR#j!k!wROPQSUVZ[adefgjlptuwz!O!R!T!U!^!`!g!j!k!n!p!s!y#U#V#W#Y#h#o#s#x#yQoPR!wpmhPQUjlptuw!T!s!y#o#sR!ofR!qgTnPpTmPpSkPpSsQwQ!PUQ!tlQ!ztQ!{uR#X!TQvQR#Ow!RYOSVZ[adez!O!R!U!^!`!g!j!k#U#V#W#Y#h#x#y!RTOSVZ[adez!O!R!U!^!`!g!j!k#U#V#W#Y#h#x#yT{T|!RWOSVZ[adez!O!R!U!^!`!g!j!k#U#V#W#Y#h#x#yQ!SVR#Z!UT!VW!Wy]OSVadez!O!R!U!g!j!k#U#V#W#Y#h#x#yR!_ZR!a[a_O`cde!i!k!mT!lc!mQpPR!xpQwQR#PwQ|TR#R|Q!WWR#[!WW`Ode!kS!f`!iT!ic!mQ!mcR#k!mWbOde!kQySS!QV!UQ!haQ#QzS#T!O!RQ#g!gQ#i!jS#v#U#VS#w#W#YQ$P#hT$S#x#yx]OSVadez!O!R!U!g!j!k#U#V#W#Y#h#x#yQ!_ZQ!a[Q#a!^R#b!`!QYOSVZ[adez!O!R!U!^!`!g!j!k#U#V#W#Y#h#x#ylhPQUjlptuw!T!s!y#o#sQ!ofQ!qgQ#l!nR#m!pSiPp^rQUltuw!TQ!rjQ#n!sQ#r!yQ$Q#oR$R#s",
  nodeNames: "âš  DirectiveEnd DocEnd - - ? ? ? Literal QuotedLiteral Anchor Alias Tag BlockLiteralContent Comment Stream BOM Document ] [ FlowSequence Item Tagged Anchored Anchored Tagged FlowMapping Pair Key : , } { FlowMapping Pair BlockSequence Item Item BlockMapping Pair Key Pair BlockLiteral BlockLiteralHeader Tagged Anchored Anchored Tagged Directive DirectiveName DirectiveContent Document",
  maxTerm: 69,
  context: indentation,
  nodeProps: [
    ["isolate", -3,8,9,14,""],
    ["openedBy", 18,"[",31,"{"],
    ["closedBy", 19,"]",32,"}"]
  ],
  propSources: [yamlHighlighting],
  skippedNodes: [0],
  repeatNodeCount: 6,
  tokenData: "-Y~RnOX#PXY$QYZ$]Z]#P]^$]^p#Ppq$Qqs#Pst$btu#Puv$yv|#P|}&e}![#P![!]'O!]!`#P!`!a'i!a!}#P!}#O*g#O#P#P#P#Q+Q#Q#o#P#o#p+k#p#q'i#q#r,U#r;'S#P;'S;=`#z<%l?HT#P?HT?HU,o?HUO#PQ#UU!SQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PQ#kTOY#PZs#Pt;'S#P;'S;=`#z<%lO#PQ#}P;=`<%l#P~$VQ!b~XY$Qpq$Q~$bO!c~~$gS^~OY$bZ;'S$b;'S;=`$s<%lO$b~$vP;=`<%l$bR%OX!SQOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR%rX!SQ!RPOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR&bP;=`<%l%kR&lUnP!SQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'VUmP!SQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'p[{P!SQOY#PZp#Ppq#hq{#P{|(f|}#P}!O(f!O!R#P!R![)p![;'S#P;'S;=`#z<%lO#PR(mW{P!SQOY#PZp#Ppq#hq!R#P!R![)V![;'S#P;'S;=`#z<%lO#PR)^U{P!SQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR)wY{P!SQOY#PZp#Ppq#hq{#P{|)V|}#P}!O)V!O;'S#P;'S;=`#z<%lO#PR*nUcP!SQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+XUbP!SQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+rUpP!SQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,]UoP!SQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,vU`P!SQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#P",
  tokenizers: [newlines, blockMark, literals, blockLiteral, 0, 1],
  topRules: {"Stream":[0,15]},
  tokenPrec: 0
});

export { parser };
